<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>zkBg NFT Verifier - Hardhat</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #424242 0%, #1c1424 100%);
            min-height: 100vh;
            color: white;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        h1 {
            text-align: center;
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ffd700, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .verifier-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
        }
        
        .input-group {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .input-group label {
            font-weight: 600;
            min-width: 100px;
        }
        
        .input-group input {
            flex: 1;
            padding: 10px;
            border-radius: 8px;
            border: none;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            font-weight: 500;
        }
        
        button {
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            font-size: 1em;
            transition: transform 0.2s, box-shadow 0.2s;
            margin: 0 10px 10px 0;
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.4);
        }
        
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .comparison-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        
        .canvas-wrapper {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }
        
        .canvas-wrapper h3 {
            color: #333;
            text-align: center;
            margin: 0 0 15px 0;
            font-size: 1.2em;
        }
        
        canvas {
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 500px;
        }
        
        .info-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
        }
        
        .data-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 0.9em;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .status-badge {
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: 600;
            margin: 5px;
            display: inline-block;
        }
        
        .status-badge.success {
            background: rgba(76, 175, 80, 0.3);
            color: #4caf50;
        }
        
        .status-badge.error {
            background: rgba(244, 67, 54, 0.3);
            color: #f44336;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .stat-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #ffd700;
        }
        
        .stat-label {
            font-size: 0.9em;
            opacity: 0.8;
            margin-top: 5px;
        }
        
        .loading {
            display: none;
            text-align: center;
            margin: 20px 0;
        }
        
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid #fff;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .highlight {
            background: rgba(255, 255, 0, 0.2);
            padding: 2px 5px;
            border-radius: 3px;
        }
        
        .address {
            font-family: monospace;
            font-size: 0.9em;
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 8px;
            border-radius: 4px;
            word-break: break-all;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç zkBg NFT Verifier</h1>
        <p style="text-align: center; opacity: 0.8; margin-bottom: 30px;">Verify that on-chain NFT data can recreate the original spiral pattern</p>
        
        <!-- Verification Input -->
        <div class="verifier-section">
            <h3>üéØ Verify NFT Data Integrity</h3>
            <div class="input-group">
                <label>Contract:</label>
                <input type="text" id="contractAddress" placeholder="0x..." value="">
            </div>
            <div class="input-group">
                <label>Token ID:</label>
                <input type="number" id="tokenId" placeholder="0" value="0">
            </div>
            <button onclick="connectWallet()" id="connectBtn">ü¶ä Connect Wallet</button>
            <button onclick="verifyNFT()" id="verifyBtn" disabled>üîç Verify NFT</button>
            <button onclick="loadFromDeployment()" style="background: linear-gradient(45deg, #ff6b6b, #ffd700);">üìã Load Contract</button>
            <button onclick="debugContract()" style="background: linear-gradient(45deg, #ff9500, #ffb347);">üîß Debug Contract</button>
        </div>
        
        <!-- Loading -->
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Reading on-chain data and reconstructing spiral...</p>
        </div>
        
        <!-- Debug Section -->
        <div id="debugResults" style="display: none;">
            <div class="info-panel">
                <h3>üîß Contract Debug Information</h3>
                <div id="debugData"></div>
            </div>
        </div>
        
        <!-- Verification Results -->
        <div id="verificationResults" style="display: none;">
            <!-- Status -->
            <div class="info-panel">
                <h3>üìä Verification Status</h3>
                <div id="verificationStatus"></div>
            </div>
            
            <!-- Comparison -->
            <div class="comparison-container">
                <div class="canvas-wrapper">
                    <h3>üîó On-Chain Data Reconstruction</h3>
                    <canvas id="onchainCanvas" width="500" height="500"></canvas>
                    <p style="color: #333; text-align: center; margin: 10px 0;">Built from smart contract data</p>
                </div>
                <div class="canvas-wrapper">
                    <h3>‚ö° Live ZK Circuit Generation</h3>
                    <canvas id="liveCanvas" width="500" height="500"></canvas>
                    <p style="color: #333; text-align: center; margin: 10px 0;">Generated using same seed</p>
                </div>
            </div>
            
            <!-- NFT Metadata -->
            <div class="info-panel">
                <h3>üìã NFT Configuration</h3>
                <div class="stats" id="nftStats"></div>
            </div>
            
            <!-- Raw Data -->
            <div class="info-panel">
                <h3>üîß Raw On-Chain Data</h3>
                <div class="data-section" id="rawData"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    
    <script>
        let CONTRACT_ADDRESS = "";
        const CONTRACT_ABI = [
            "function getSpiralConfig(uint256 tokenId) view returns (tuple(uint64 seed, uint64 variant, uint8 spiralType, uint8 numArms, uint64 spiralQuotient, uint64 armsQuotient, uint64 armsRemainder))",
            "function getTriangleCount(uint256 tokenId) view returns (uint256)",
            "function getTriangleData(uint256 tokenId, uint256 index) view returns (tuple(uint16 x1, uint16 y1, uint16 x2, uint16 y2, uint16 x3, uint16 y3, uint8 armIndex, uint8 triangleIndex))",
            "function tokenURI(uint256 tokenId) view returns (string)",
            "function ownerOf(uint256 tokenId) view returns (address)",
            "function balanceOf(address owner) view returns (uint256)",
            "function totalSupply() view returns (uint256)",
            "function name() view returns (string)",
            "function symbol() view returns (string)",
            "event SpiralMinted(uint256 indexed tokenId, address indexed minter, uint64 seed, uint8 spiralType, uint8 numArms)"
        ];
        
        let provider;
        let contract;
        
        // Connect wallet
        async function connectWallet() {
            if (typeof window.ethereum === 'undefined') {
                alert('Please install MetaMask!');
                return;
            }
            
            try {
                await window.ethereum.request({ method: 'eth_requestAccounts' });
                provider = new ethers.providers.Web3Provider(window.ethereum);
                
                const network = await provider.getNetwork();
                if (network.chainId !== 1337) {
                    alert('Please switch to Hardhat Local Network (Chain ID: 1337)');
                    return;
                }
                
                document.getElementById('connectBtn').textContent = '‚úÖ Connected';
                document.getElementById('connectBtn').disabled = true;
                document.getElementById('verifyBtn').disabled = false;
                
                console.log('Wallet connected to Hardhat');
            } catch (error) {
                console.error('Error connecting wallet:', error);
                alert('Error connecting wallet: ' + error.message);
            }
        }
        
        // Load contract address from deployment
        async function loadFromDeployment() {
            try {
                const response = await fetch('/deployments.json');
                if (response.ok) {
                    const deployment = await response.json();
                    if (deployment.network === 'localhost' || deployment.network === 'hardhat') {
                        CONTRACT_ADDRESS = deployment.address;
                        document.getElementById('contractAddress').value = CONTRACT_ADDRESS;
                        console.log('Loaded contract address:', CONTRACT_ADDRESS);
                    } else {
                        alert('Deployment file is not for localhost/hardhat network');
                    }
                } else {
                    alert('Could not load deployments.json. Make sure it exists in static folder.');
                }
            } catch (error) {
                console.error('Error loading deployment:', error);
                alert('Error loading deployment: ' + error.message);
            }
        }
        async function debugContract() {
            const contractAddr = document.getElementById('contractAddress').value;
            
            if (!contractAddr) {
                alert('Please enter contract address first');
                return;
            }
            
            if (!provider) {
                alert('Please connect your wallet first');
                return;
            }
            
            document.getElementById('loading').style.display = 'block';
            
            try {
                // Initialize contract
                contract = new ethers.Contract(contractAddr, CONTRACT_ABI, provider);
                
                console.log('Debugging contract:', contractAddr);
                
                let debugInfo = `<h4>üìã Contract Information</h4>`;
                
                // Basic contract info
                try {
                    const name = await contract.name();
                    const symbol = await contract.symbol();
                    debugInfo += `<p><strong>Name:</strong> ${name}</p>`;
                    debugInfo += `<p><strong>Symbol:</strong> ${symbol}</p>`;
                } catch (e) {
                    debugInfo += `<p><strong>Error getting name/symbol:</strong> ${e.message}</p>`;
                }
                
                // Get connected wallet info
                const signer = provider.getSigner();
                const userAddress = await signer.getAddress();
                debugInfo += `<p><strong>Your address:</strong> <span class="address">${userAddress}</span></p>`;
                
                // Check user's balance
                try {
                    const balance = await contract.balanceOf(userAddress);
                    debugInfo += `<p><strong>Your NFT balance:</strong> ${balance.toString()}</p>`;
                } catch (e) {
                    debugInfo += `<p><strong>Error getting balance:</strong> ${e.message}</p>`;
                }
                
                // Try to get total supply (if available)
                try {
                    const totalSupply = await contract.totalSupply();
                    debugInfo += `<p><strong>Total minted:</strong> ${totalSupply.toString()}</p>`;
                } catch (e) {
                    debugInfo += `<p><strong>Total supply not available</strong> (older ERC721)</p>`;
                }
                
                // Check events to see what tokens were minted
                debugInfo += `<h4>üîç Searching for Minted Tokens</h4>`;
                
                try {
                    // Get minting events from the last 1000 blocks
                    const currentBlock = await provider.getBlockNumber();
                    const fromBlock = Math.max(0, currentBlock - 1000);
                    
                    const filter = contract.filters.SpiralMinted();
                    const events = await contract.queryFilter(filter, fromBlock, currentBlock);
                    
                    debugInfo += `<p><strong>Minting events found:</strong> ${events.length}</p>`;
                    
                    if (events.length > 0) {
                        debugInfo += `<h5>Recent Mints:</h5>`;
                        events.forEach((event, i) => {
                            const { tokenId, minter, seed, spiralType, numArms } = event.args;
                            const spiralTypes = ['Tight', 'Loose', 'Classic'];
                            debugInfo += `
                                <div style="background: rgba(255,255,255,0.05); padding: 10px; margin: 5px 0; border-radius: 5px;">
                                    <strong>Token ID ${tokenId.toString()}</strong><br>
                                    Minter: <span class="address">${minter}</span><br>
                                    Seed: ${seed.toString()}, Type: ${spiralTypes[spiralType]}, Arms: ${numArms}<br>
                                    Block: ${event.blockNumber}
                                </div>
                            `;
                        });
                        
                        // Suggest token IDs to try
                        const tokenIds = events.map(e => e.args.tokenId.toString());
                        debugInfo += `<p><strong>üí° Try these Token IDs:</strong> ${tokenIds.join(', ')}</p>`;
                    } else {
                        debugInfo += `<p style="color: #f44336;"><strong>‚ö†Ô∏è No minting events found!</strong></p>`;
                        debugInfo += `<p>This could mean:</p>`;
                        debugInfo += `<ul style="margin-left: 20px;">`;
                        debugInfo += `<li>No NFTs have been minted yet</li>`;
                        debugInfo += `<li>You're checking the wrong contract address</li>`;
                        debugInfo += `<li>The contract was deployed recently and events are outside search range</li>`;
                        debugInfo += `</ul>`;
                    }
                } catch (e) {
                    debugInfo += `<p><strong>Error searching events:</strong> ${e.message}</p>`;
                }
                
                // Test token ID 0 specifically
                debugInfo += `<h4>üß™ Testing Token ID 0</h4>`;
                try {
                    const owner0 = await contract.ownerOf(0);
                    debugInfo += `<p><strong>Token 0 owner:</strong> <span class="address">${owner0}</span> ‚úÖ</p>`;
                } catch (e) {
                    debugInfo += `<p><strong>Token 0:</strong> Does not exist ‚ùå</p>`;
                    debugInfo += `<p><em>Error: ${e.message}</em></p>`;
                }
                
                // Test a few more token IDs
                for (let i = 1; i <= 5; i++) {
                    try {
                        const owner = await contract.ownerOf(i);
                        debugInfo += `<p><strong>Token ${i} owner:</strong> <span class="address">${owner}</span> ‚úÖ</p>`;
                    } catch (e) {
                        debugInfo += `<p><strong>Token ${i}:</strong> Does not exist ‚ùå</p>`;
                    }
                }
                
                document.getElementById('debugData').innerHTML = debugInfo;
                document.getElementById('debugResults').style.display = 'block';
                
            } catch (error) {
                console.error('Error debugging contract:', error);
                document.getElementById('debugData').innerHTML = `
                    <p style="color: #f44336;"><strong>‚ùå Debug Error:</strong></p>
                    <p>${error.message}</p>
                    <p><strong>Possible issues:</strong></p>
                    <ul style="margin-left: 20px;">
                        <li>Contract address is incorrect</li>
                        <li>Contract is not deployed</li>
                        <li>Network mismatch (not on Hardhat)</li>
                        <li>Contract doesn't implement expected functions</li>
                    </ul>
                `;
                document.getElementById('debugResults').style.display = 'block';
            } finally {
                document.getElementById('loading').style.display = 'none';
            }
        }
        async function loadFromDeployment() {
            try {
                const response = await fetch('/deployments.json');
                if (response.ok) {
                    const deployment = await response.json();
                    if (deployment.network === 'localhost' || deployment.network === 'hardhat') {
                        CONTRACT_ADDRESS = deployment.address;
                        document.getElementById('contractAddress').value = CONTRACT_ADDRESS;
                        console.log('Loaded contract address:', CONTRACT_ADDRESS);
                    } else {
                        alert('Deployment file is not for localhost/hardhat network');
                    }
                } else {
                    alert('Could not load deployments.json. Make sure it exists in static folder.');
                }
            } catch (error) {
                console.error('Error loading deployment:', error);
                alert('Error loading deployment: ' + error.message);
            }
        }
        
        // Verify NFT
        async function verifyNFT() {
            const contractAddr = document.getElementById('contractAddress').value;
            const tokenId = document.getElementById('tokenId').value;
            
            if (!contractAddr || !tokenId) {
                alert('Please enter contract address and token ID');
                return;
            }
            
            if (!provider) {
                alert('Please connect your wallet first');
                return;
            }
            
            document.getElementById('loading').style.display = 'block';
            document.getElementById('verificationResults').style.display = 'none';
            
            try {
                // Initialize contract
                contract = new ethers.Contract(contractAddr, CONTRACT_ABI, provider);
                
                console.log('Reading NFT data from contract...');
                
                // Get spiral configuration
                const spiralConfig = await contract.getSpiralConfig(tokenId);
                console.log('Spiral config:', spiralConfig);
                
                // Get triangle count
                const triangleCount = await contract.getTriangleCount(tokenId);
                console.log('Triangle count:', triangleCount.toString());
                
                // Get all triangle data
                const triangles = [];
                for (let i = 0; i < triangleCount; i++) {
                    const triangleData = await contract.getTriangleData(tokenId, i);
                    triangles.push({
                        vertices: [
                            [triangleData.x1, triangleData.y1],
                            [triangleData.x2, triangleData.y2],
                            [triangleData.x3, triangleData.y3]
                        ],
                        arm_index: triangleData.armIndex,
                        triangle_index: triangleData.triangleIndex
                    });
                }
                
                // Get token URI and metadata
                let tokenURI, metadata;
                try {
                    tokenURI = await contract.tokenURI(tokenId);
                    if (tokenURI.startsWith('data:application/json;base64,')) {
                        const base64Data = tokenURI.split(',')[1];
                        metadata = JSON.parse(atob(base64Data));
                    }
                } catch (e) {
                    console.log('Could not decode token URI:', e);
                }
                
                // Get owner
                let owner;
                try {
                    owner = await contract.ownerOf(tokenId);
                } catch (e) {
                    console.log('Could not get owner:', e);
                }
                
                // Reconstruct spiral from on-chain data
                const reconstructedSpiral = {
                    seed: spiralConfig.seed.toString(),
                    variant: spiralConfig.variant.toString(),
                    spiral_type: spiralConfig.spiralType,
                    num_arms: spiralConfig.numArms,
                    triangles: triangles,
                    config: {
                        spiral_quotient: spiralConfig.spiralQuotient.toString(),
                        arms_quotient: spiralConfig.armsQuotient.toString(),
                        arms_remainder: spiralConfig.armsRemainder.toString()
                    }
                };
                
                // Generate fresh spiral from ZK circuit using same seed
                const liveSpiral = await generateSpiralFromSeed(parseInt(reconstructedSpiral.seed));
                
                // Display results
                displayVerificationResults(reconstructedSpiral, liveSpiral, {
                    tokenId,
                    contractAddr,
                    owner,
                    metadata,
                    tokenURI
                });
                
            } catch (error) {
                console.error('Error verifying NFT:', error);
                alert('Error verifying NFT: ' + error.message);
            } finally {
                document.getElementById('loading').style.display = 'none';
            }
        }
        
        // Generate spiral from seed using ZK circuit
        async function generateSpiralFromSeed(seed) {
            try {
                const response = await fetch('/api/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ seed: seed, canvas_size: 500 })
                });
                
                if (!response.ok) {
                    throw new Error(`ZK circuit API error: ${response.status}`);
                }
                
                return await response.json();
            } catch (error) {
                console.error('Error generating spiral from ZK circuit:', error);
                throw error;
            }
        }
        
        // Display verification results
        function displayVerificationResults(onchainSpiral, liveSpiral, nftInfo) {
            // Draw both spirals
            drawSpiral(document.getElementById('onchainCanvas'), onchainSpiral, 'On-Chain Data');
            drawSpiral(document.getElementById('liveCanvas'), liveSpiral, 'Live Generation');
            
            // Compare and show status
            const isMatch = compareSpirals(onchainSpiral, liveSpiral);
            
            document.getElementById('verificationStatus').innerHTML = `
                <div class="status-badge ${isMatch ? 'success' : 'error'}">
                    ${isMatch ? '‚úÖ VERIFIED: On-chain data matches ZK circuit output' : '‚ùå MISMATCH: Data integrity issue detected'}
                </div>
                <p style="margin-top: 15px;">
                    <strong>Token ID:</strong> ${nftInfo.tokenId}<br>
                    <strong>Contract:</strong> <span class="address">${nftInfo.contractAddr}</span><br>
                    <strong>Owner:</strong> <span class="address">${nftInfo.owner || 'Unknown'}</span>
                </p>
            `;
            
            // Show NFT stats
            const spiralTypes = ['Tight', 'Loose', 'Classic'];
            document.getElementById('nftStats').innerHTML = `
                <div class="stat-item">
                    <div class="stat-value">${onchainSpiral.seed}</div>
                    <div class="stat-label">Seed</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${spiralTypes[onchainSpiral.spiral_type]}</div>
                    <div class="stat-label">Type</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${onchainSpiral.num_arms}</div>
                    <div class="stat-label">Arms</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${onchainSpiral.triangles.length}</div>
                    <div class="stat-label">Triangles</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${liveSpiral.triangles.length}</div>
                    <div class="stat-label">Live Gen Triangles</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${isMatch ? 'MATCH' : 'DIFFER'}</div>
                    <div class="stat-label">Verification</div>
                </div>
            `;
            
            // Show raw data
            document.getElementById('rawData').innerHTML = `
                <h4>On-Chain Configuration:</h4>
                <pre>${JSON.stringify(onchainSpiral, null, 2)}</pre>
                
                <h4 style="margin-top: 20px;">Token Metadata:</h4>
                <pre>${JSON.stringify(nftInfo.metadata, null, 2)}</pre>
                
                <h4 style="margin-top: 20px;">Triangle Comparison (first 5):</h4>
                <pre>${compareTriangleDetails(onchainSpiral.triangles, liveSpiral.triangles)}</pre>
            `;
            
            document.getElementById('verificationResults').style.display = 'block';
        }
        
        // Compare spirals for verification
        function compareSpirals(onchain, live) {
            // Check basic config
            if (onchain.seed !== live.seed.toString()) return false;
            if (onchain.spiral_type !== live.spiral_type) return false;
            if (onchain.num_arms !== live.num_arms) return false;
            
            // Check triangle count
            if (onchain.triangles.length !== live.triangles.length) return false;
            
            // Check first few triangles for vertex match (allowing small rounding differences)
            for (let i = 0; i < Math.min(5, onchain.triangles.length); i++) {
                const onchainTri = onchain.triangles[i];
                const liveTri = live.triangles[i];
                
                for (let v = 0; v < 3; v++) {
                    const diff_x = Math.abs(onchainTri.vertices[v][0] - liveTri.vertices[v][0]);
                    const diff_y = Math.abs(onchainTri.vertices[v][1] - liveTri.vertices[v][1]);
                    
                    if (diff_x > 1 || diff_y > 1) { // Allow 1 pixel difference for rounding
                        return false;
                    }
                }
            }
            
            return true;
        }
        
        // Compare triangle details for display
        function compareTriangleDetails(onchainTriangles, liveTriangles) {
            let comparison = "";
            
            for (let i = 0; i < Math.min(5, onchainTriangles.length, liveTriangles.length); i++) {
                const onchain = onchainTriangles[i];
                const live = liveTriangles[i];
                
                comparison += `Triangle ${i}:\n`;
                comparison += `  On-chain: ${JSON.stringify(onchain.vertices)}\n`;
                comparison += `  Live:     ${JSON.stringify(live.vertices)}\n`;
                comparison += `  Match: ${JSON.stringify(onchain.vertices) === JSON.stringify(live.vertices) ? 'YES' : 'CLOSE'}\n\n`;
            }
            
            return comparison;
        }
        
        // Draw spiral on canvas
        function drawSpiral(canvas, spiralData, title) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Background
            const gradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, canvas.width/2);
            gradient.addColorStop(0, '#0a0a0a');
            gradient.addColorStop(1, '#1a1a1a');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw triangles
            const armColors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3', '#a8e6cf', '#ff8b94'];
            
            spiralData.triangles.forEach((triangle, index) => {
                const color = armColors[triangle.arm_index % armColors.length];
                
                ctx.beginPath();
                ctx.moveTo(triangle.vertices[0][0], triangle.vertices[0][1]);
                ctx.lineTo(triangle.vertices[1][0], triangle.vertices[1][1]);
                ctx.lineTo(triangle.vertices[2][0], triangle.vertices[2][1]);
                ctx.closePath();
                
                ctx.fillStyle = color + '80';
                ctx.fill();
                
                ctx.strokeStyle = color;
                ctx.lineWidth = 1;
                ctx.stroke();
            });
            
            // Draw title
            ctx.fillStyle = '#ffffff';
            ctx.font = '14px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(title, canvas.width/2, 20);
            
            // Draw center point
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(canvas.width/2, canvas.height/2, 4, 0, 2 * Math.PI);
            ctx.fill();
        }
        
        // Load contract address on page load
        window.addEventListener('load', () => {
            loadFromDeployment();
        });
    </script>
</body>
</html>